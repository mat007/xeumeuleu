<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2002-2005 The Apache Software Foundation or its licensors,
  as applicable.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>Manual</title>
  </header>
  <body>
    <section id="usage">
      <title>Using the library</title>
      <p>
        Only one include statement is necessary :
      </p>
      <source><![CDATA[#include <xeumeuleu/xml.h>]]></source>
      <p>
        Should an error happen manipulating a stream an exception of type <em>xml::exception</em> which derives from <em>std::exception</em> will be raised.
      </p>
      <p>
        Such an exception can also be raised manually by calling the <em>error</em> method on an <em>xml::xistream</em>.<br />
        This can be used to decorate a custom error message with the context of the error (file name and/or line and column numbers) if available.
      </p>
    </section>
    <section id="creation">
      <title>Creating a stream</title>
      <p>
        The next step is to create the proper stream depending on the needs.
      </p>
      <section id="input">
        <title>Input streams</title>
        <p>
          The following code creates a stream from an XML document contained in an <em>std::string</em> :
        </p>
        <source><![CDATA[xml::xistringstream xis( string );]]></source>
        <p>
          The following code creates a stream from an XML document contained in a file <em>file.xml</em> :
        </p>
        <source><![CDATA[xml::xifstream xis( "file.xml" );]]></source>
        <p>
          The following code creates a stream from an XML document contained in a <em>std::istream</em> :
        </p>
        <source><![CDATA[std::istringstream stream( string );
xml::xistreamstream xis( stream );]]></source>
        <p>
          The following code clones a given existing stream <em>xis</em> :
        </p>
        <source><![CDATA[xml::xibufferstream xibs( xis );]]></source>
        <p>
          The purpose of this stream implementation is to bufferize XML in order to read it later.
        </p>
        <p>
          The following code branches a given existing stream <em>xis</em> :
        </p>
        <source><![CDATA[xml::xisubstream xiss( xis );]]></source>
        <p>
          The purpose of this stream implementation is to perform operations on <em>xiss</em> without impacting <em>xis</em>.<br />
          Obviously the life-time of the sub-stream must not exceed the life-time of the underlying stream.
        </p>
        <p>
          The following code combines two streams <em>xis1</em> and <em>xis2</em> into a single stream :
        </p>
        <source><![CDATA[xml::ximultistream xis( xis1, xis2 );]]></source>
        <p>
          The purpose of this stream implementation is to read from two streams transparently as if there was one stream.<br />
          If one piece of data is available in both streams, the first one takes precedence, otherwise it is pulled from any of the streams as needed.<br />
          The life-time of the composite stream must not exceed the life-time of the underlying streams.
        </p>
      </section>
      <section id="output">
        <title>Output streams</title>
        <p>
          The following code creates a stream to write an XML document to an <em>std::string</em> :
        </p>
        <source><![CDATA[xml::xostringstream xos;]]></source>
        <p>
          After the serialization is finished the resulting document can be retrieved :
        </p>
        <source><![CDATA[const std::string xml = xos.str();]]></source>
        <p>
          The following code creates a stream to write an XML document to a file <em>file.xml</em> :
        </p>
        <source><![CDATA[xml::xofstream xos( "file.xml" );]]></source>
        <p>
          The following code creates a stream to write an XML document to a buffer :
        </p>
        <source><![CDATA[xml::xobufferstream xobs;]]></source>
        <p>
          The purpose of this type of stream is to bufferize XML in order to serialize it later in another output stream, for example :
        </p>
        <source><![CDATA[xml::xofstream xos( "file.xml" );
xos << xobs;]]></source>
        <p>
          The following code branches a given existing stream <em>xos</em> :
        </p>
        <source><![CDATA[xml::xosubstream xoss( xos );]]></source>
        <p>
          The purpose of this stream implementation is to perform operations on <em>xoss</em> without impacting <em>xos</em>.<br />
          Obviously the life-time of the sub-stream must not exceed the life-time of the underlying stream.
        </p>
      </section>
      <section id="encoding">
        <title>Encoding</title>
        <p>
          By default the encoding type of an input stream will be detected in the document prolog if available, example :
        </p>
        <source><![CDATA[<?xml version="1.0" encoding="UTF-8" ?>
<element/>]]></source>
        <p>
          If no encoding is specified or no prolog is available, the encoding will be assumed to be UTF-8.
        </p>
        <p>
          An output stream will be encoded in UTF-8 by default.
        </p>
        <p>
          The encoding type can be forced at creation time, for example :
        </p>
          <source><![CDATA[xml::xostringstream xos( xml::encoding( "UTF-16" ) );]]></source>
        <p>
          Or :
        </p>
        <source><![CDATA[xml::xifstream xis( "file.xml", xml::encoding( "ISO-8859-1" ) );]]></source>
        <p>
          For the list of possible encoding values see "<a href="site:xerces/encodings">What encodings are supported by Xerces-C / XML4C?</a>".
        </p>
      </section>
      <section id="validation">
        <title>Validation</title>
        <p>
          By default validation will only occur if an XML schema definition (XSD) is specified when creating an input stream :
        </p>
        <source><![CDATA[xml::xostringstream xos( xml::external_grammar( "example.xsd" ) );]]></source>
        <p>
          Multiple schema definitions can also be specified :
        </p>
        <source><![CDATA[xml::xostringstream xos( xml::external_grammar( "example.xsd test.xsd" ) );]]></source>
        <p>
          Sometimes an embedded schema definition has been specified in the document :
        </p>
        <source><![CDATA[<?xml version="1.0" encoding="UTF-8" ?>
<element xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="example.xsd" >]]></source>
        <p>
          A special <em>internal_grammar</em> has to be used :
        </p>
        <source><![CDATA[xml::xostringstream xos( xml::internal_grammar() );]]></source>
        <p>
          The default behaviour is not to validate against internal schema definitions because it may require an internet connection.
        </p>
        <p>
          Combining internal and external schema validations is not supported at the moment.
        </p>
      </section>
    </section>
    <section id="walking">
      <title>Walking the tree</title>
      <p>
        Elements are (un)serialized in order to process an XML document.
      </p>
      <section id="elements">
        <title>Elements</title>
        <p>
          Elements are (un)serialized using <strong>xml::start</strong> and <strong>xml::end</strong>, for example :
        </p>
        <source><![CDATA[xos << xml::start( "element" ) << xml::end();]]></source>
        <p>
          An important feature concerning input streams is that when unserializing an element the first available child matching the given name will be pulled.
        </p>
        <p>
          This allows to ignore elements ordering as for the following XML document :
        </p>
        <source><![CDATA[<root>
  <first-element/>
  <second-element/>
</root>]]></source>
        <p>
          The following unserialization code is valid :
        </p>
        <source><![CDATA[xis >> xml::start( "root" )
      >> xml::start( "second-element" ) >> xml::end()
      >> xml::start( "first-element" ) >> xml::end()
    >> xml::end()]]></source>
        <p>
          Of course as a side effect the following code appears to be also valid :
        </p>
        <source><![CDATA[xis >> xml::start( "root" )
      >> xml::start( "first-element" ) >> xml::end()
      >> xml::start( "first-element" ) >> xml::end()
      >> xml::start( "first-element" ) >> xml::end()
    >> xml::end();]]></source>
        <p>
          It is also considered valid for some nodes to be left unserialized and therefore no exception will be raised.
        </p>
        <p>
          An <strong>xml::xistream</strong> can also be used as an element in order to be directly copied into an <strong>xml::xostream</strong>, for example given the following input :
        </p>
        <source><![CDATA[<root>
  <element>
    <sub-element/>
  </element>
</root>]]></source>
        <p>
          The following code :
        </p>
        <source><![CDATA[xml::xifstream xis( "file.xml" );
xis >> xml::start( "root" );
xml::xostringstream xos;
xos << xis;]]></source>
        <p>
          Will result in the following output document :
        </p>
        <source><![CDATA[<element/>
  <sub-element/>
</element>]]></source>
      </section>
      <section id="lists">
        <title>Lists of elements</title>
        <p>
          In order to cope with lists of elements of the same name in input streams <strong>xml::list</strong> can be used, for example for the following document :
        </p>
        <source><![CDATA[<root>
  <element/>
  <element/>
  <element/>
</root>]]></source>
        <p>
          The following code will be used :
        </p>
        <source><![CDATA[xis >> xml::start( "root" )
      >> xml::list( "element", my_instance, &my_class::my_method )
    >> xml::end();]]></source>
        <p>
          Where <em>my_instance</em> is an instance of a functor class <em>my_class</em> which method <em>my_method</em> signature will be :
        </p>
        <source><![CDATA[class my_class
{
public:
    void my_method( xistream& xis );
};]]></source>
        <p>
          Note that the functor method can be declared <em>const</em> if needed.
        </p>
        <p>
          For each <em>element</em> the functor method will be called and the stream passed as parameter will be ready to handle the branch as if the corresponding child element had been unserialized.<br />
          If no child of the given name can be found the functor method will not be called but no exception will be raised.
        </p>
        <p>
          Additionally if custom parameters are needed within the functor method they can be passed to <strong>xml::list</strong>, for example :
        </p>
        <source><![CDATA[int my_integer = 3;
std::string my_string = "something";
xis >> xml::start( "root" )
      >> xml::list( "element", my_instance, &my_class::my_method, my_integer, my_string )
    >> xml::end();]]></source>
        <p>
          The functor method signature will be expected to be called with the given parameters :
        </p>
        <source><![CDATA[class my_class
{
public:
    void my_method( xistream& xis, int my_integer, const std::string& my_string ) const;
};]]></source>
        <p>
          Note that each parameter can be declared <em>const</em> or not depending on the needs.
        </p>
        <p>
          Another version of <strong>xml::list</strong> exists which does not take an element name as first parameter, but instead discovers every element and for each one calls a functor with its name.<br />
          This allows to read an heterogeneous list of elements when the ordering matters, for example with the document :
        </p>
        <source><![CDATA[<root>
  <first-element/>
  <second-element/>
  <third-element/>
</root>]]></source>
        <p>
          The following code will call a functor for each element :
        </p>
        <source><![CDATA[xis >> xml::start( "root" )
    >> xml::list( my_instance, &my_class::my_method )
  >> xml::end();]]></source>
        <p>
          With the functor method signature being :
        </p>
        <source><![CDATA[class my_class
{
public:
    void my_method( const std::string& name, xistream& xis ) const;
};]]></source>
      <p>
        The <em>name</em> argument will be <em>first-element</em>, <em>second-element</em> and then <em>third-element</em> : the order of the calls matches the order of the elements in the document.
      </p>
      </section>
      <section id="optional-element">
        <title>Optional elements</title>
        <p>
          If an element is optional in an input stream, <strong>xml::optional</strong> can be used during unserialization, for example the following document :
        </p>
        <source><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<element/>]]></source>
        <p>
          Can be unserialized with :
        </p>
        <source><![CDATA[xis >> xml::start( "element" )
      >> xml::optional() >> xml::start( "non-existing-child" )
        >> xml::start( "non-existing-grand-child" )
        >> xml::attribute( "name", name )
        >> xml::end()
      >> xml::end()
    >> xml::end();]]></source>
        <p>
          No exception will be raised as the whole <em>non-existing-child</em> branch will be skipped.<br />
          Obviously <em>name</em> will not be read, which points out the fact that when using <strong>xml::optional</strong> data should probably be initialized with default values prior to unserialization.
        </p>
      </section>
    </section>
    <section id="data">
      <title>Managing data</title>
      <p>
        Supported data types are :
      </p>
      <ul>
        <li>std::string</li>
        <li>const char* (handled as strings and only for output streams)</li>
        <li>bool</li>
        <li>short</li>
        <li>int</li>
        <li>long</li>
        <li>long long</li>
        <li>float</li>
        <li>double</li>
        <li>unsigned short</li>
        <li>unsigned int</li>
        <li>unsigned long</li>
        <li>unsigned long long</li>
      </ul>
      <section id="contents">
        <title>Contents</title>
        <p>
          The content of an element can be directly (un)serialized, for example :
        </p>
        <source><![CDATA[xos << xml::start( "element" )
      << "the text content of the node"
    << xml::end();]]></source>
        <p>
          Will produce the following XML document :
        </p>
        <source><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<element>
  the text content of the node
</element>]]></source>
        <p>
          As convenience <strong>xml::content</strong> is a shortcut to manage the previous manipulation in one step, for example :
        </p>
        <source><![CDATA[xos << xml::content( "element", "the text content of the node" );]]></source>
        <p>
          Will perform the exact same operation.
        </p>
        <p>
          A CDATA section happens to be unserialized transparently either directly or with an <strong>xml::content</strong>, however it must be manually serialized, for example :
        </p>
        <source><![CDATA[xos << xml::start( "element" )
        << xml::cdata( "the CDATA section of the node" )
      << xml::end();]]></source>
        <p>
          It is worth noting that <strong>xml::cdata</strong> can be used inside an <strong>xml::content</strong> :
        </p>
        <source><![CDATA[xos << xml::content( "element", xml::cdata( "the CDATA section of the node" ) );]]></source>
        <p>
          Reading the content of a node is also possible using the following helper function, either :
        </p>
        <source><![CDATA[const std::string result = xml::value< std::string >( xis );]]></source>
        <p>
          Or by providing a default value if content is optional :
        </p>
        <source><![CDATA[const std::string result = xml::value< std::string >( xis, "a default value" );]]></source>
        <p>
          Alternatively another helper function reads the content inside a given node directly :
        </p>
        <source><![CDATA[const std::string result = xml::content< std::string >( xis, "element" );]]></source>
        <p>
          Or also by providing a default value if the node and/or its content is optional :
        </p>
        <source><![CDATA[const std::string result = xml::content( xis, "element", "a default value" );]]></source>
        <p>
          Note that the first forms require the template to be explicited whereas the second forms deduce it from the default value parameter type.
        </p>
      </section>
      <section id="attributes">
        <title>Attributes</title>
        <p>
          Coping with attributes involves using <strong>xml::attribute</strong>, for example :
        </p>
        <source><![CDATA[xos << xml::start( "element" )
    << xml::attribute( "name", "the-name" )
    << xml::end();]]></source>
        <p>
          Will produce the following XML document :
        </p>
        <source><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<element name="the-name"/>]]></source>
        <p>
          Reading an attribute is also possible in a one line statement, using either :
        </p>
        <source><![CDATA[const std::string result = xml::attribute< std::string >( xis, "attribute" );]]></source>
        <p>
          Or by providing a default value if the attribute is optional :
        </p>
        <source><![CDATA[const std::string result = xml::attribute( xis, "attribute", "a default value" );]]></source>
        <p>
          Note that the first version requires the template to be explicited whereas the second version deduces it from the default value parameter type.
        </p>
      </section>
      <section id="attribute-lists">
        <title>Lists of attributes</title>
        <p>
          In the same way as nodes, attributes can also be enumerated, for example given the following document :
        </p>
        <source><![CDATA[<root first="value 1" second="value 2"/>]]></source>
        <p>
          A functor to handle the attributes when their names are unknown at the compile time would be :
        </p>
        <source><![CDATA[class my_class
{
public:
    void my_method( const std::string& name, xistream& xis ) const;
};]]></source>
        <p>
          Note that this functor has the exact same signature as the similar <strong>xml::list</strong> functor.
        </p>
        <p>
          With <em>my-instance</em> being an object of type <em>my_class</em>, the document can be read by the following piece of code :
        </p>
        <source><![CDATA[xis >> xml::start( "root" )
      >> xml::attributes( my_instance, &my_class::my_method )
    >> xml::end();]]></source>
      <p>
        The functor will be called a first time with <em>name</em> equal to <em>first</em> and a second time with <em>name</em> equal to <em>second</em>.
        The <em>xis</em> parameter will be an input stream already placed on the <em>root</em> node.
      </p>
      </section>
      <section id="optional-data">
        <title>Optional data</title>
        <p>
          An optional content can be handled by the <strong>xml::optional</strong> feature :
        </p>
        <source><![CDATA[xis >> xml::optional() >> content;]]></source>
        <p>
          The variable <em>content</em> will not be read if the current node does not have any content and no exception will be raised.
        </p>
        <p>
          Just the same way an optional attribute can be skipped silently :
        </p>
        <source><![CDATA[xis >> xml::start( "element" )
      >> xml::optional() >> xml::attribute( "name", name )
    >> xml::end();]]></source>
        <p>
          The variable <em>name</em> will not be read if the attribute <em>name</em> does not exist in the XML document and no exception will be raised.
        </p>
      </section>
    </section>
  </body>
</document>
